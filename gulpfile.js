var config = {
	"src": {
		"path": "app/",
		"files": {			
			"ts": "./app/**/*.ts",
			"html": "./app/**/*.htm'",
			"css": "./app/**/*.css",
			"other": "./app/**/*!(.ts)",
			"all":	"./app/**/*.*"
		}
		
	},
	"build": {
		"path": ".build/",
		"routes": {
                "/jspm_packages": "jspm_packages"
        }				
	},
	"tsd": {		
        "command": "reinstall",
		"latest": false,
        "config": "./tsd.json"		
	}
}
var gulp = require('gulp');
var ts = require('gulp-typescript');
var merge = require('merge2');
var browserSync = require('browser-sync').create();
var tsProject = ts.createProject(config.src.path+'tsconfig.json');
var tsd = require('gulp-tsd'); 

gulp.task('tsd', tsd_task);
gulp.task('build', build_task);
gulp.task('dev',['tsd','gen','build'], dev_task);

function tsd_task(callback) { tsd(config.tsd, callback); }
function dev_task() {
    browserSync.init({
        server: {
            baseDir: config.build.path,
            routes: config.build.routes,
            reloadDelay: 2500
        }
    });
    gulp.watch(config.src.files.all, function() {        
            //gen_task();
            build_task();        
            browserSync.reload();               
    });    
}
function build_task() {
    var tsResult = gulp.src( config.src.files.ts ).pipe(ts(tsProject));
    var other = gulp.src( config.src.files.other );
        
    return merge([ // Merge the two output streams, so this task is finished when the IO of both operations are done. 
        tsResult.dts.pipe(gulp.dest( config.build.path)),
        tsResult.js.pipe(gulp.dest( config.build.path)),
        other.pipe(gulp.dest( config.build.path)),
        gulp.src( 'config.js').pipe(gulp.dest( config.build.path))
    ]);    
}



//-------- generate interfaces -------------------------------------
gulp.task('gen', gen_task);

function gen_task(){
    var outputPath ="webef/interfaces.ts";
    var schemaPath = 'webef/schema.json';
    
    
    var db = require('./'+config.src.path + schemaPath);

    var namemap = {};
    var output = [];
    
    output.push('// WARNING: This file was generated by a gulp task\n\n');
    output.push('import {DBSchema, DBContext, DBEntity} from \'./ef\'\n');
    output.push('DBSchema.create(\'./'+schemaPath+'\');\n\n')
    
    for (var table in db.schema){
        var name = table.substr(0,1).toUpperCase()+table.substr(1);
        namemap[table] = name;
    }
    
    var dbContextClass = [];
    dbContextClass.push('export class MyDBContext extends DBContext<DBMasterContext> {\n')
    dbContextClass.push('\tconstructor(){super(\''+db.name+'\')}\n')
    var masterContextMap = {};
    
    for (var table in db.schema){
        var name = namemap[table];
    
        var entityInterface = [];
        var entityContextInterface = [];
        var contextInterface = [];    
        var otherTables = [];

        entityInterface.push('export interface '+name+' {\n');
        entityContextInterface.push('export interface '+name+'Table extends lf.schema.Table {\n');
        contextInterface.push('export interface '+name+'Context {\n');
        contextInterface.push('\t'+table+'?: '+name+'Table;\n');        
        masterContextMap[table] = '\t'+table+'?: '+name+'Table;\n';  
        
        for(var column in db.schema[table]){
            var def = removeWhiteSpace(db.schema[table][column]);
            
            var nullable = '';
            if (def.indexOf('null')!== -1){
                nullable = '?';
            }               
            if (def.indexOf('pkey')===0 || def.indexOf('fk')===0){
                entityInterface.push('\t'+column+'?: number;\n'); 
                entityContextInterface.push('\t'+column+'?: lf.schema.Column;\n');
            }
            if (def.indexOf('nav->')===0){
                var x=def.split('>')[1].split(':');
                var y=x[1].split('.');
                
                var tableName=x[0];
                var fkTable=y[0];
                var fkColumn=y[1];
                var isArray = (fkTable !== table);
                var className = namemap[tableName];
                var ifArray = isArray ? '[]' : '';
                entityInterface.push('\t'+column+'?: '+className+ifArray+';\n');
                contextInterface.push('\t'+tableName+'?: '+className+'Table;\n');
                masterContextMap[tableName] = '\t'+tableName+'?: '+className+'Table;\n';                
                otherTables.push(tableName);
            }
            if (def.indexOf('float')===0){
                entityInterface.push('\t'+column+nullable+': number;\n'); 
                entityContextInterface.push('\t'+column+nullable+': lf.schema.Column;\n');                
            }
            if (def.indexOf('string')===0){
                entityInterface.push('\t'+column+nullable+': string;\n'); 
                entityContextInterface.push('\t'+column+nullable+': lf.schema.Column;\n');                
            }
            if (def.indexOf('boolean')===0){
                entityInterface.push('\t'+column+nullable+': boolean;\n'); 
                entityContextInterface.push('\t'+column+nullable+': lf.schema.Column;\n');                
            }                            
            if (def.indexOf('date')===0){
                entityInterface.push('\t'+column+nullable+': Date;\n'); 
                entityContextInterface.push('\t'+column+nullable+': lf.schema.Column;\n');                
            }                     
            if (def.indexOf('int')===0){
                entityInterface.push('\t'+column+nullable+': number;\n'); 
                entityContextInterface.push('\t'+column+nullable+': lf.schema.Column;\n');                
            }   
            if (def.indexOf('object')===0){
                entityInterface.push('\t'+column+nullable+': Object;\n'); 
                entityContextInterface.push('\t'+column+nullable+': lf.schema.Column;\n');                
            }   
            if (def.indexOf('array')===0){
                entityInterface.push('\t'+column+nullable+': any[];\n'); 
                entityContextInterface.push('\t'+column+nullable+': lf.schema.Column;\n');                
            }     
                  
        }
        
        dbContextClass.push('\tpublic '+table+' = this.DBEntity<'+name+', '+name+'Context>(\''+table+'\', '+JSON.stringify(otherTables)+');\n')
        
        entityInterface.push('}\n\n');
        entityContextInterface.push('}\n\n');
        if (contextInterface.length>0) contextInterface.push('}\n\n');
        
        output.push( entityInterface.join('') )
        output.push( entityContextInterface.join('') )
        output.push( contextInterface.join('') )
    }
    
    var masterContext = [];
    masterContext.push('export interface DBMasterContext {\n');
    for (var key in masterContextMap){
        masterContext.push(masterContextMap[key]);
    }
    masterContext.push('}\n\n');
    output.push( masterContext.join(''));
    
    dbContextClass.push('}\n\n');
    output.push( dbContextClass.join(''));
    var text = output.join('');
    
    var fs = require('fs');
    fs.writeFileSync(config.src.path + outputPath, text);    
}
function removeWhiteSpace(str) {
    return str.replace(/\s/g, "");
}


